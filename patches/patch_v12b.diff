*** Begin Patch
*** Update File: requirements.txt
@@
-numpy<2
+numpy<2
 pandas>=2.0
 joblib>=1.3
 matplotlib>=3.7
 scipy>=1.10
 tqdm>=4.66
+typing-extensions>=4.8
 
*** End Patch

*** Begin Patch
*** Update File: src/utils.py
@@
-import numpy as np
+import numpy as np
+
+def _to_numpy(x):
+    """
+    Convierte torch.Tensor -> numpy (float) de forma segura.
+    Si ya es array-like, devuelve np.asarray(x).
+    """
+    try:
+        import torch
+        if isinstance(x, torch.Tensor):
+            return x.detach().float().cpu().numpy()
+    except Exception:
+        pass
+    return np.asarray(x)
 
 def spectral_entropy(x, eps=1e-12):
-    X = np.fft.rfft(x - np.mean(x))
-    P = (np.abs(X) ** 2)
-    P /= (np.sum(P) + eps)
-    H = -np.sum(P * (np.log(P + eps)))
-    return float(H)
+    x = _to_numpy(x)
+    # Guardas para series demasiado cortas:
+    if x is None or x.size < 4:
+        return 0.0
+    x = x - np.mean(x)
+    X = np.fft.rfft(x)
+    if X.size == 0:
+        return 0.0
+    P = (np.abs(X) ** 2)
+    Z = np.sum(P)
+    if Z <= eps:
+        return 0.0
+    P = P / Z
+    H = -np.sum(P * (np.log(P + eps)))
+    return float(H)
+
+def ensure_numpy(*arrs):
+    """Devuelve todas las entradas como np.ndarray (conversion segura desde torch)."""
+    return tuple(_to_numpy(a) for a in arrs)
*** End Patch

*** Begin Patch
*** Update File: src/model.py
@@
-import numpy as np
+import os
+import numpy as np
+try:
+    import torch
+    _TORCH_OK = True
+except Exception:
+    torch = None
+    _TORCH_OK = False
 from .utils import spectral_entropy
@@
-    def __init__(self, cfg, rng=None):
-        self.cfg = cfg
-        self.rng = rng
-        self.device = "cpu"
-        self.dtype = None
+    def __init__(self, cfg, rng=None):
+        self.cfg = cfg
+        self.rng = rng
+        use_gpu = bool(int(os.getenv("USE_GPU", "0")))
+        if use_gpu:
+            if not (_TORCH_OK and torch.cuda.is_available()):
+                raise RuntimeError("GPU requested but torch is not available on this machine.")
+            self.device = torch.device("cuda")
+            self.dtype = torch.float32
+            self.use_torch = True
+        else:
+            self.device = "cpu"
+            self.dtype = None
+            self.use_torch = False
@@
-    def run(self, gamma, xi_amp, seed, out_dir):
-        # ... inicializaciones ...
+    def run(self, gamma, xi_amp, seed, out_dir):
+        # --- gamma como escalar consistente ---
+        if getattr(self, "use_torch", False):
+            self.gamma_t = torch.tensor(float(gamma), device=self.device, dtype=self.dtype)
+            if self._step_counter == 0 if hasattr(self, "_step_counter") else True:
+                print(f"[debug] gamma_t={self.gamma_t.item():.6g} xi={xi_amp} device={self.device}")
+        else:
+            self.gamma_t = float(gamma)
+            if self._step_counter == 0 if hasattr(self, "_step_counter") else True:
+                print(f"[debug] gamma={self.gamma_t:.6g} xi={xi_amp} device=cpu")
+        self._step_counter = 0
@@
-        Hs = [spectral_entropy(x) for x in samples_Q]
-        lpc_viol_frac = self.measure_lpc_violation(Hs)
+        Hs = [spectral_entropy(x) for x in samples_Q] if samples_Q else []
+        lpc_viol_frac = self.measure_lpc_violation(Hs)
+        lpc_ok_frac = 1.0 - float(lpc_viol_frac)
@@
-            "lpc_viol_frac": float(lpc_viol_frac),
+            "lpc_viol_frac": float(lpc_viol_frac),
+            "lpc_ok_frac": float(lpc_ok_frac),
*** End Patch

*** Begin Patch
*** Update File: src/model.py
@@
-    def step_euler(self, xi_amp):
-        # ejemplo anterior: Mterm = np.sum(self.Y, axis=1)
-        Mterm = np.sum(self.Y, axis=1)
+    def step_euler(self, xi_amp):
+        # ejemplo anterior: Mterm = np.sum(self.Y, axis=1)  -> compatible con torch/numpy
+        Mterm = (self.Y.sum(dim=1) if ('torch' in globals() and hasattr(self, "use_torch") and self.use_torch and isinstance(self.Y, torch.Tensor))
+                 else np.sum(self.Y, axis=1))
         # ... usa gamma (float) ...
*** End Patch

*** Begin Patch
*** Update File: src/run_sim.py
@@
-import pandas as pd
-df = pd.DataFrame(rows)
-df.to_csv(out_dir / "table_full.csv", index=False)
-with open(out_dir / "summary.csv", "w") as f:
-    f.write(df.describe().to_csv())
+import pandas as pd
+df = pd.DataFrame(rows)
+df.to_csv(out_dir / "table_full.csv", index=False)
+summary = (df.groupby(["gamma","xi"], as_index=False)
+             .agg(ceff_bar=("ceff_bar","mean"),
+                  anisotropy_rel=("anisotropy_rel","mean"),
+                  hbar_eff=("hbar_eff","mean"),
+                  lpc_viol_frac=("lpc_viol_frac","mean"),
+                  lpc_ok_frac=("lpc_ok_frac","mean"),
+                  runs=("seed","count")))
+summary.to_csv(out_dir / "summary.csv", index=False)
*** End Patch